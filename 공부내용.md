## 브라우저 동작 원리

브라우저는 기본적으로 하나의 메인 스레드에서 자바스크립트 실행과 화면 렌더링을 함께 처리한다. 즉, js 코드가 실행되는 동안에는 화면을 그리는 작업도 기다려야 한다. 그래서 자바스크립트가 오래 실행되면 버튼이 눌리지 않거나 화면이 멈춘 것처럼 보이는 현상이 발생한다.

자바스크립트 엔진은 코드를 실행할 때 Call Stack이라는 공간을 사용한다. 여기에 함수가 스택에 쌓이고 위에서부터 하나씩 실행된다. 중요한 점은 스택이 비워지기 전까지는 다른 작업을 할 수 없다는 것, 그래서 자바스크립트는 싱글 스레드라고 말한다. 동시에 여러 코드를 실행하는 것이 아니라 반드시 하나가 끝나야 다음 것이 실행된다.

그런데 웹에서는 타이머나 네트워크 요청처럼 시간이 걸리는 작업이 많다. 이런 작업까지 전부 스택에서 기다리게 하면 브라우저는 계속 멈춰 있을 것이다. 이를 해결하기 위해 브라우저는 Web APIs라는 별도의 기능을 제공한다. setTimeout, setInterval, requestAnimtaionFrame, fetch, 클릭 이벤트 같은 것들이 여기에 속한다. 자바스크립트는 이런 작업을 직접 처리하지 않고 브라우저에게 맡긴다. 예를 들어 setTimeout을 호출하면 이 함수는 1초 뒤에 실행해줘라고 요청만 하고 다음 코드를 바로 실행한다.

이 작업이 끝나면 바로 실행되는 것이 아니라 Queue로 들어간다. 이후 이벤트 루프는 계속 반복하면서 지금 Call Stack이 비어있는가를 확인한다. 만약 비어 있다면 Queue에 있는 콜백을 스택으로 옮겨 실행한다. 반대로 스택이 아직 실행 중이라면 기다린다. 이 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기 처리가 가능 한 것이다.

```
JS 코드 → Call Stack에서 실행

오래 걸리는 작업 발견
   → Web APIs에게 맡김

작업 완료
   → Queue에서 대기

Event Loop가 계속 체크
   "Stack 비었나?"

비었으면
   → Queue → Stack 이동 후 실행

```

### 렌더링

브라우저는 우리가 코드를 실행할 때마다 화면을 다시 그리는 것이 아니라 일정한 주기로 화면을 업데이트 한다. 보통 초당 약 60번, 약 16ms마다 한 번씩 화면을 그린다. 이 한 번의 사이클을 프레임이라고 부른다. 하나의 프레임 안에서는 다음 순서가 진행된다.
먼저 자바스크립트를 실행하고 그 다음 스타일을 계산하고, 요소들의 위치를 계산한 뒤 실제 픽셀을 그리는 과정을 거쳐 화면에 출력한다.

1. JavaScript 실행

2. Style 계산

3. Layout 계산 (요소 위치 및 크기)

4. Paint (픽셀 렌더링)

5. 화면 출력

### requestAnimationFrame vs setInterval

requestAnimationFrame 함수는 브라우저에게 다음 화면을 그리기 직전에 이 코드를 실행해줘라고 요청하는 방식이다. 즉 렌더링 타이밍과 정확히 맞물려 실행된다 그래서 애니메이션처럼 화면 변화가 중요한 작업에서 매우 효율적이다. 브라우저가 프레임을 준비할 때만 실행되기 때문에 불필요한 호출이 줄어들고, 프레임이 끊기는 현상도 줄어든다.

반대로 setInterval은 렌더링 타이밍을 전혀 고려하지 않는다. 단순히 지정한 시간이 지났으니 실행해야 한다는 기준만 가지고 Queue에 들어온다. 만약 브라우저가 이미 무거운 작업을 처리 중이라면 타이머 콜백이 밀려들어오면서 메인 스레드가 더 바빠질 수 있고, 그 결과 화면이 버벅일 수도 있다.

또 다른 차이로는 백그라운드 탭에서 나타난다. 사용자가 다른 탭으로 이동하면 브라우저는 굳이 화면을 그릴 필요가 없다고 판단한다. 그래서 requestAnimationFrame은 거의 실행되지 않거나 멈춘다. 하지만 setInterval은 여전히 동작하려고 한다. 사용자가 보지도 않는 화면을 위해 CPU를 계속 사용하는 셈이다.

## 정리

자바스크립트와 렌더링은 같은 스레드를 사용하기 때문에 JS가 무거워질수록 화면은 멈춘다. 그래서 브라우저의 동작 방식에 맞춰 코드를 실행하는 것이 중요하다.

자바스크립트는 Call Stack에서 하나씩 실행되고 시간이 걸리는 작업은 Web APIs에 맡겨졌다가 Queue로 돌아온다. Event Loop는 스택이 비었을 때만 그 작업을 실행한다. 그리고 브라우저는 약 16ms마다 한 번씩 화면을 그린다. requestAnimationFrame은 그리기 직전에 실행되어 렌더링 흐름에 자연스럽게 맞춰지고 setInterval은 그런 흐름과 무관하게 동작한다.
