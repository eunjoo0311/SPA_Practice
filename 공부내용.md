## 브라우저 동작 원리

브라우저는 기본적으로 하나의 메인 스레드에서 자바스크립트 실행과 화면 렌더링을 함께 처리한다. 즉, js 코드가 실행되는 동안에는 화면을 그리는 작업도 기다려야 한다. 그래서 자바스크립트가 오래 실행되면 버튼이 눌리지 않거나 화면이 멈춘 것처럼 보이는 현상이 발생한다.

자바스크립트 엔진은 코드를 실행할 때 Call Stack이라는 공간을 사용한다. 여기에 함수가 스택에 쌓이고 위에서부터 하나씩 실행된다. 중요한 점은 스택이 비워지기 전까지는 다른 작업을 할 수 없다는 것, 그래서 자바스크립트는 싱글 스레드라고 말한다. 동시에 여러 코드를 실행하는 것이 아니라 반드시 하나가 끝나야 다음 것이 실행된다.

그런데 웹에서는 타이머나 네트워크 요청처럼 시간이 걸리는 작업이 많다. 이런 작업까지 전부 스택에서 기다리게 하면 브라우저는 계속 멈춰 있을 것이다. 이를 해결하기 위해 브라우저는 Web APIs라는 별도의 기능을 제공한다. setTimeout, setInterval, requestAnimationFrame, fetch, 클릭 이벤트 같은 것들이 여기에 속한다. 자바스크립트는 이런 작업을 직접 처리하지 않고 브라우저에게 맡긴다. 예를 들어 setTimeout을 호출하면 이 함수는 1초 뒤에 실행해줘라고 요청만 하고 다음 코드를 바로 실행한다.

이 작업이 끝나면 바로 실행되는 것이 아니라 Queue로 들어간다. 이후 이벤트 루프는 계속 반복하면서 지금 Call Stack이 비어있는가를 확인한다. 만약 비어 있다면 Queue에 있는 콜백을 스택으로 옮겨 실행한다. 반대로 스택이 아직 실행 중이라면 기다린다. 이 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기 처리가 가능 한 것이다.

```
JS 코드 → Call Stack에서 실행

오래 걸리는 작업 발견
   → Web APIs에게 맡김

작업 완료
   → Queue에서 대기

Event Loop가 계속 체크
   "Stack 비었나?"

비었으면
   → Queue → Stack 이동 후 실행

```

### 렌더링

브라우저는 우리가 코드를 실행할 때마다 화면을 다시 그리는 것이 아니라 일정한 주기로 화면을 업데이트 한다. 보통 초당 약 60번, 약 16ms마다 한 번씩 화면을 그린다. 이 한 번의 사이클을 프레임이라고 부른다. 하나의 프레임 안에서는 다음 순서가 진행된다.
먼저 자바스크립트를 실행하고 그 다음 스타일을 계산하고, 요소들의 위치를 계산한 뒤 실제 픽셀을 그리는 과정을 거쳐 화면에 출력한다.

1. JavaScript 실행

2. Style 계산

3. Layout 계산 (요소 위치 및 크기)

4. Paint (픽셀 렌더링)

5. 화면 출력

### requestAnimationFrame vs setInterval

requestAnimationFrame 함수는 브라우저에게 다음 화면을 그리기 직전에 이 코드를 실행해줘라고 요청하는 방식이다. 즉 렌더링 타이밍과 정확히 맞물려 실행된다 그래서 애니메이션처럼 화면 변화가 중요한 작업에서 매우 효율적이다. 브라우저가 프레임을 준비할 때만 실행되기 때문에 불필요한 호출이 줄어들고, 프레임이 끊기는 현상도 줄어든다.

반대로 setInterval은 렌더링 타이밍을 전혀 고려하지 않는다. 단순히 지정한 시간이 지났으니 실행해야 한다는 기준만 가지고 Queue에 들어온다. 만약 브라우저가 이미 무거운 작업을 처리 중이라면 타이머 콜백이 밀려들어오면서 메인 스레드가 더 바빠질 수 있고, 그 결과 화면이 버벅일 수도 있다.

또 다른 차이로는 백그라운드 탭에서 나타난다. 사용자가 다른 탭으로 이동하면 브라우저는 굳이 화면을 그릴 필요가 없다고 판단한다. 그래서 requestAnimationFrame은 거의 실행되지 않거나 멈춘다. 하지만 setInterval은 여전히 동작하려고 한다. 사용자가 보지도 않는 화면을 위해 CPU를 계속 사용하는 셈이다.

## 정리

자바스크립트와 렌더링은 같은 스레드를 사용하기 때문에 JS가 무거워질수록 화면은 멈춘다. 그래서 브라우저의 동작 방식에 맞춰 코드를 실행하는 것이 중요하다.

자바스크립트는 Call Stack에서 하나씩 실행되고 시간이 걸리는 작업은 Web APIs에 맡겨졌다가 Queue로 돌아온다. Event Loop는 스택이 비었을 때만 그 작업을 실행한다. 그리고 브라우저는 약 16ms마다 한 번씩 화면을 그린다. requestAnimationFrame은 그리기 직전에 실행되어 렌더링 흐름에 자연스럽게 맞춰지고 setInterval은 그런 흐름과 무관하게 동작한다.

### Microtask vs Macrotask

브라우저에는 크게 두 종류의 큐가 존재한다. MicroTask Queue와 MacroTask Queue로 Event Loop는 이 두 큐를 아무렇게나 처리하지 않고 우선순위를 기준으로 실행한다.

먼저 Macrotask는 일반적으로 떠올리는 비동기 작업들이 들어가는 큐이다. setTimeout, setInterval, 클릭 이벤트, 네트워크 요청 같은 것들이 대표적이 예시이다. 이런 작업들은 지금 당장 실행되기보다는 다음 작업 사이클에서 처리해도 괜찮은 것들이라고 볼 수 있다.

반면 Microtask는 더 높은 우선순위를 가진다. 대표적으로 Promise.then, catch, finally 같은 작업이 여기에 들어간다. Microtask는 현재 실행 중인 작업이 끝난 직후 가능한 한 빨리 처리되어야 하는 후속 작업이다. 예를 들어 Promise는 보통 어떤 연산의 결과를 바로 이어서 처리해야 하기 때문에 지연되면 프로그램 흐름이 어색해질 수 있다. 그래서 브라우저는 Microtask를 먼저 처리하도록 설계되어 있다.

Event Loop의 동작흐름은 먼저 Call Stack에 있는 코드를 모두 실행한다.그리고 Stack이 비게 되면 바로 MacroTask로 가지 않고 반드시 MicroTask Queue를 먼저 전부 비운다. MicroTask가 모두 실행된 뒤에야 Macrotask 하나를 가져와 실행한다. 그리고 그 MacroTask 실행이 끝아면 다시 Microtask를 전부 확인한다. 이 과정이 계속 반복된다.

## Web Worker

자바스크립트는 기본적으로 하나의 메인 스레드에서 동작하기 때문에 무거운 연산이 실행되면 화면이 멈추거나 입력이 늦게 반응하는 문제가 생길 수 있다. 이 문제를 해결하기 위해 브라우저는 Web Worker라는 기능을 제공한다. Web Worker는 자바스크립트를 메인 스레드가 아닌 별도의 백그라운드 스레드에서 실행할 수 있게 해주는 기능이다.

Worker를 사용하면 시간 계산, 대량 데이터 처리, 복잡한 연산과 같은 작업을 메인 스레드에서 분리할 수 있다. 이때 중요한 점은 Worker는 완전히 다른 스레드에서 동작하기 때문에 메인 스레드의 Call Stack과는 별도록 실행된다는 것이다. 메인 스레드가 화면을 그리거나 이벤트를 처리하는 동안에도 Worker는 계속 계산을 진행할 수 있다.

그러나 Worker는 화면을 직접 조작할 수 없다. DOM에 접근하거나 document, window 같은 객체를 사용할 수 없기 때문이다. 대신 Worker는 계산 결과를 postMessage라는 방식으로 메인 스레드에 전달하고, 메인 스레드는 그 값을 받아 화면에 업데이트 한다. 이 구조 덕분에 연산과 렌더링을 분리할 수 있게 된다.

```
메인 스레드
   ↓
Worker 생성 (new Worker)

Worker 스레드에서 연산 수행
   ↓
postMessage로 결과 전달
   ↓
메인 스레드는 화면만 업데이트
```

### Web Worker 정리

Web Worker는 자바스크립트의 싱글 스레드 구조를 보완하기 위한 기능이다.
메인 스레드가 화면과 이벤트를 담당하고 Worker는 계산을 담당한다.
Worker는 DOM을 직접 제어할 수 없지만 메시지를 통해 메인 스레드와 통신한다.
